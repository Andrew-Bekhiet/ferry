(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{53:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var i=t(2),a=t(6),o=(t(0),t(86)),r={id:"cache-configuration",title:"Configuring the cache",sidebar_label:"Configuration"},c={unversionedId:"cache-configuration",id:"cache-configuration",isDocsHomePage:!1,title:"Configuring the cache",description:"The Ferry cache normalizes incoming data for your GraphQL operations and stores it using a Store. This allows the client to respond to future queries for the same data without sending unnecessary network requests.",source:"@site/../docs/cache-configuration.md",slug:"/cache-configuration",permalink:"/docs/cache-configuration",editUrl:"https://github.com/gql-dart/ferry/edit/master/docs/../docs/cache-configuration.md",version:"current",sidebar_label:"Configuration",sidebar:"mainSidebar",previous:{title:"Error Handling",permalink:"/docs/error-handling"},next:{title:"Reading and Writing Data to the Cache",permalink:"/docs/cache-interaction"}},s=[{value:"Data Normalization",id:"data-normalization",children:[{value:"Passing the possibleTypes Map",id:"passing-the-possibletypes-map",children:[]},{value:"Generating Unique Identifiers",id:"generating-unique-identifiers",children:[]},{value:"Disabling Normalization",id:"disabling-normalization",children:[]}]},{value:"<code>TypePolicy</code> Fields",id:"typepolicy-fields",children:[{value:"Overriding Root Operation Types (Uncommon)",id:"overriding-root-operation-types-uncommon",children:[]},{value:"The <code>fields</code> Property",id:"the-fields-property",children:[]}]}],l={rightToc:s};function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The Ferry cache normalizes incoming data for your GraphQL operations and stores it using a ",Object(o.b)("inlineCode",{parentName:"p"},"Store"),". This allows the client to respond to future queries for the same data without sending unnecessary network requests."),Object(o.b)("h2",{id:"data-normalization"},"Data Normalization"),Object(o.b)("p",null,"Normalization involves the following steps:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The cache ",Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#generating-unique-identifiers"}),"generates a unique ID")," for every identifiable object included in the response."),Object(o.b)("li",{parentName:"ol"},"The cache stores the objects by ID in a flat lookup table."),Object(o.b)("li",{parentName:"ol"},"Whenever an incoming object is stored with the same ID as an ",Object(o.b)("em",{parentName:"li"},"existing")," object, the fields of those objects are ",Object(o.b)("em",{parentName:"li"},"merged"),".",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"If the incoming object and the existing object share any fields, the incoming object ",Object(o.b)("em",{parentName:"li"},"overwrites")," the cached values for those fields."),Object(o.b)("li",{parentName:"ul"},"Fields that appear in ",Object(o.b)("em",{parentName:"li"},"only")," the existing object or ",Object(o.b)("em",{parentName:"li"},"only")," the incoming object are preserved.")))),Object(o.b)("p",null,"Normalization constructs a partial copy of your data graph on your client, in a format that's optimized for reading and updating the graph as your application changes state."),Object(o.b)("h3",{id:"passing-the-possibletypes-map"},"Passing the possibleTypes Map"),Object(o.b)("p",null,"When the schema contains unions, interfaces queries use fragments, the cache needs a little help\nto correctly normalize/denormalize data.\nIn this case, pass the ",Object(o.b)("inlineCode",{parentName:"p"},"possibleTypes")," parameter to the cache constructor.\nThis is a Map containing subtype information from the schema.\nIt is generated by ",Object(o.b)("inlineCode",{parentName:"p"},"ferry_generator")," and located in your schema.gql.dart file. "),Object(o.b)("p",null,"If you run into ",Object(o.b)("inlineCode",{parentName:"p"},"DeserializationError"),"s when using the cache and not passing the possibleTypes map,\nthis is probably the issue you're running into."),Object(o.b)("h3",{id:"generating-unique-identifiers"},"Generating Unique Identifiers"),Object(o.b)("p",null,"By default, the cache generates a unique identifier using an object's ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," and any uniquely identifying fields, called ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields"),". By default, the ",Object(o.b)("inlineCode",{parentName:"p"},"id")," or ",Object(o.b)("inlineCode",{parentName:"p"},"_id")," field (whichever is defined) is used as a ",Object(o.b)("inlineCode",{parentName:"p"},"keyField"),", but this behavior can be ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#customizing-identifier-generation-by-type"}),"customized"),". These two values are separated by a colon (",Object(o.b)("inlineCode",{parentName:"p"},":"),")."),Object(o.b)("p",null,"For example, an object with a ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Task")," and an ",Object(o.b)("inlineCode",{parentName:"p"},"id")," of ",Object(o.b)("inlineCode",{parentName:"p"},"14")," is assigned a default identifier of ",Object(o.b)("inlineCode",{parentName:"p"},"Task:14"),"."),Object(o.b)("h4",{id:"customizing-identifier-generation-by-type"},"Customizing Identifier Generation by Type"),Object(o.b)("p",null,"If one of your types defines its primary key with a field ",Object(o.b)("em",{parentName:"p"},"besides")," ",Object(o.b)("inlineCode",{parentName:"p"},"id")," or ",Object(o.b)("inlineCode",{parentName:"p"},"_id"),", you can customize how the cache generates unique identifiers for that type. To do so, you define ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," for the type and include a Map of all your ",Object(o.b)("inlineCode",{parentName:"p"},"typePolicies")," when instantiating the cache."),Object(o.b)("p",null,"Include a ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields")," field in relevant ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," objects, like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-dart"}),"final cache = Cache(\n  typePolicies: {\n    'Product': TypePolicy(\n      // In most inventory management systems, a single UPC code uniquely\n      // identifies any product.\n      keyFields: {\n        'upc': true,\n      },\n    ),\n    'Person': TypePolicy(\n      // In some user account systems, names or emails alone do not have to\n      // be unique, but the combination of a person's name and email is\n      // uniquely identifying.\n      keyFields: {\n        'name': true,\n        'email': true,\n      },\n    ),\n    'Book': TypePolicy(\n      // If one of the keyFields is an object with fields of its own, you can\n      // include those nested keyFields by using a nested array of strings:\n      keyFields: {\n        'title': true,\n        'author': {\n          'name': true,\n        },\n      },\n    ),\n  },\n);\n")),Object(o.b)("p",null,"This example shows three ",Object(o.b)("inlineCode",{parentName:"p"},"typePolicies"),": one for a ",Object(o.b)("inlineCode",{parentName:"p"},"Product")," type, one for a ",Object(o.b)("inlineCode",{parentName:"p"},"Person")," type, and one for a ",Object(o.b)("inlineCode",{parentName:"p"},"Book")," type. Each ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy"),"'s ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields")," array defines which fields on the type ",Object(o.b)("em",{parentName:"p"},"together")," represent the type's primary key."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Book")," type above uses a ",Object(o.b)("em",{parentName:"p"},"subfield")," as part of its primary key. The ",Object(o.b)("inlineCode",{parentName:"p"},"Book"),"'s ",Object(o.b)("inlineCode",{parentName:"p"},"author")," field must be an object that includes a ",Object(o.b)("inlineCode",{parentName:"p"},"name")," field for this to be valid."),Object(o.b)("p",null,"In the example above, the resulting identifier string for a ",Object(o.b)("inlineCode",{parentName:"p"},"Book")," object has the following structure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),'Book:{"author":{"name":"Ray Bradbury"}, "title":"Fahrenheit 451"}\n')),Object(o.b)("p",null,"An object's primary key fields are always listed alphabetically to ensure uniqueness."),Object(o.b)("p",null,"Note that these ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields")," strings always refer to the actual field names as defined in your schema, meaning the ID computation is not sensitive to field aliases."),Object(o.b)("h3",{id:"disabling-normalization"},"Disabling Normalization"),Object(o.b)("p",null,"You can instruct Ferry ",Object(o.b)("em",{parentName:"p"},"not")," to normalize objects of a certain type. This can be useful for metrics and other transient data that's identified by a timestamp and never receives updates."),Object(o.b)("p",null,"To disable normalization for a type, define a ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," for the type (as shown in ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#customizing-identifier-generation-by-type"}),"Customizing Identifier Generation by Type"),") and set the policy's ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields")," field to an empty ",Object(o.b)("inlineCode",{parentName:"p"},"Map"),"."),Object(o.b)("p",null,"Objects that are not normalized are instead embedded within their ",Object(o.b)("em",{parentName:"p"},"parent")," object in the cache. You can't access these objects directly, but you can access them via their parent."),Object(o.b)("h2",{id:"typepolicy-fields"},Object(o.b)("inlineCode",{parentName:"h2"},"TypePolicy")," Fields"),Object(o.b)("p",null,"To customize how the cache interacts with specific types in your schema, you can provide an object mapping ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," strings to ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," objects when you create a new ",Object(o.b)("inlineCode",{parentName:"p"},"Cache"),"."),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," object can include the following fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-dart"}),"class TypePolicy {\n  /// Allows defining the primary key fields for this type.\n  ///\n  /// Pass a `true` value for any fields you wish to use as key fields. You can\n  /// also use child fields.\n  ///\n  /// ```dart\n  /// final bookTypePolicy = TypePolicy(\n  ///   keyFields: {\n  ///     'title': true,\n  ///     'author': {\n  ///       'name': true,\n  ///     }\n  ///   },\n  /// );\n  /// ```\n  ///\n  /// If you don't wish to normalize this type, simply pass an empty `Map`. In\n  /// that case, we won't normalize this type and it will be reachable from its\n  /// parent.\n  Map<String, dynamic> keyFields;\n\n  /// Set to `true` if this type is the root Query in your schema.\n  bool queryType;\n\n  /// Set to `true` if this type is the root Mutation in your schema.\n  bool mutationType;\n\n  /// Set to `true` if this type is the root Subscription in your schema.\n  bool subscriptionType;\n\n  /// Allows defining [FieldPolicy]s for this type.\n  Map<String, FieldPolicy> fields;\n\n  TypePolicy({\n    this.keyFields,\n    this.queryType = false,\n    this.mutationType = false,\n    this.subscriptionType = false,\n    this.fields = const {},\n  });\n}\n")),Object(o.b)("h3",{id:"overriding-root-operation-types-uncommon"},"Overriding Root Operation Types (Uncommon)"),Object(o.b)("p",null,"In addition to ",Object(o.b)("inlineCode",{parentName:"p"},"keyFields"),", a ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," can indicate that it represents the root query, mutation, or subscription type by setting ",Object(o.b)("inlineCode",{parentName:"p"},"queryType"),", ",Object(o.b)("inlineCode",{parentName:"p"},"mutationType"),", or ",Object(o.b)("inlineCode",{parentName:"p"},"subscriptionType")," as ",Object(o.b)("inlineCode",{parentName:"p"},"true"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-dart"}),"final cache = Cache(\n  typePolicies: {\n    'UnconventionalRootQuery': TypePolicy(\n      queryType: true,\n    ),\n  },\n);\n")),Object(o.b)("p",null,"The cache normally obtains ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," information by adding the ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," field to every GraphQL operation selection set it sends to the server. The ",Object(o.b)("inlineCode",{parentName:"p"},"__typename")," of the root query or mutation is almost always simply ",Object(o.b)("inlineCode",{parentName:"p"},'"Query"')," or ",Object(o.b)("inlineCode",{parentName:"p"},'"Mutation"'),", so the cache assumes those common defaults unless instructed otherwise in a ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy"),"."),Object(o.b)("h3",{id:"the-fields-property"},"The ",Object(o.b)("inlineCode",{parentName:"h3"},"fields")," Property"),Object(o.b)("p",null,"The final property within ",Object(o.b)("inlineCode",{parentName:"p"},"TypePolicy")," is the ",Object(o.b)("inlineCode",{parentName:"p"},"fields")," property, which is a map from string field names to ",Object(o.b)("inlineCode",{parentName:"p"},"FieldPolicy")," objects."))}p.isMDXComponent=!0},86:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return y}));var i=t(0),a=t.n(i);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),p=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},b=function(e){var n=p(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=a.a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=p(t),u=i,y=b["".concat(r,".").concat(u)]||b[u]||d[u]||o;return t?a.a.createElement(y,c(c({ref:n},l),{},{components:t})):a.a.createElement(y,c({ref:n},l))}));function y(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=u;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,r[1]=c;for(var l=2;l<o;l++)r[l]=t[l];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);